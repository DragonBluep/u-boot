baudrate=115200
loadaddr=43100000
ipaddr=192.168.1.1
serverip=192.168.1.254
ethaddr=aa:bb:cc:dd:ee:ff
file_bl2=preloader.bin
file_fip=bl31-uboot.fip
file_fw=firmware.bin
file_ik=initramfs-kernel.bin
bootcmd=if test x$ubien = xtrue; then run ubi_read_fw; else run nand_read_fw; fi && bootm $loadaddr
bootmenu_0=[36m[1mExec default boot command[0m=run bootcmd; echo [31m[1mBoot failed![0m; sleep 3; reset
bootmenu_1=[36m[1mBoot system from Flash[0m=run bootcmd; echo [31m[1mBoot failed![0m; pause; bootmenu 60
bootmenu_2=[32m[1mLoad initramfs image via TFTP then boot[0m=run tftp_boot_ik; pause; bootmenu 60
bootmenu_3=[32m[1mLoad system via TFTP then write to Flash[0m=run tftp_update_fw; pause; bootmenu 60
bootmenu_4=[33m[1mLoad BL2 via TFTP then write to Flash[0m=run tftp_update_bl2; pause; bootmenu 60
bootmenu_5=[33m[1mLoad FIP via TFTP then write to Flash[0m=run tftp_update_fip; pause; bootmenu 60
bootmenu_6=[34m[1mSwitch NAND UBI layer[0m=run switch_ubi; pause; bootmenu 60
bootmenu_7=[35m[1mReboot[0m=reset
check_bl2_integrity=if run md5_verify_bl2; then echo [31m[1mBL2 upgrade successful![0m; else echo [31m[1mBL2 upgrade failed![0m; fi
check_fip_integrity=if run md5_verify_fip; then echo [31m[1mFIP upgrade successful![0m; else echo [31m[1mFIP upgrade failed![0m; fi
check_itbimg=imsz $loadaddr fitsize && setexpr fitsize $fitsize + 80000 && extsize=$fitsize && setenv fitsize && test $extsize -gt $filesize
continue_or_not=askenv token [31m[1mContinue? [Y/n][0m 1 && char=$token && setenv token; test x$char = xy || test x$char = xY
initcmd=run set_macaddr && setenv set_macaddr && setenv initcmd
md5_verify_bl2=md5sum $loadaddr $filesize sum && hash=$sum && setenv sum && mtd read bl2 $loadaddr && md5sum -v $loadaddr $filesize $hash
md5_verify_fip=md5sum $loadaddr $filesize sum && hash=$sum && setenv sum && mtd read fip $loadaddr && md5sum -v $loadaddr $filesize $hash
nand_prep_erase=setexpr iosize $filesize + 1ffff && setexpr iosize $iosize / 20000 && setexpr iosize $iosize * 20000
nand_prep_read=setexpr iosize $iosize + 7ff && setexpr iosize $iosize / 800 && setexpr iosize $iosize * 800
nand_prep_write=setexpr iosize $filesize + 7ff && setexpr iosize $iosize / 800 && setexpr iosize $iosize * 800
nand_read_fw=mtd read ubi $loadaddr 0 20000 && imsz $loadaddr iosize && run nand_prep_read && mtd read ubi $loadaddr 0 $iosize && setenv iosize
nand_write_bl2=run continue_or_not && mtd erase bl2 && run nand_prep_write && mtd write bl2 $loadaddr 0 $iosize && setenv iosize
nand_write_fip=run continue_or_not && mtd erase fip && run nand_prep_write && mtd write fip $loadaddr 0 $iosize && setenv iosize
nand_write_fw=ubi detach && run nand_prep_erase && mtd erase ubi 0 $iosize && run nand_prep_write && mtd write ubi $loadaddr 0 $iosize && setenv iosize
set_macaddr=mtd read factory $loadaddr && setexpr ptr $loadaddr + a002a && readmem -b ethaddr $ptr && setenv ptr
setup_netcon=setenv ncip $serverip && setenv stdin nc && setenv stdout nc && setenv stderr nc
setup_uartcon=setenv stderr serial@11002000 && setenv stdout serial@11002000 && setenv stdin serial@11002000 && setenv ncip
switch_console=if test x$stdin = xnc; then run setup_uartcon && setenv bootdelay; else run setup_netcon && setenv bootdelay 60; fi
switch_ubi=if test x$ubien = xtrue; then setenv ubien false && echo [31m[1mUBI detached![0m; else setenv ubien true && echo [31m[1mUBI attached![0m; fi && saveenv
tftp_boot_ik=while true; do tftpboot $loadaddr $file_ik && bootm $loadaddr; sleep 3; done
tftp_update_bl2=mw.b $loadaddr ff 080000 && tftpboot $loadaddr $file_bl2 && run nand_write_bl2 && run check_bl2_integrity
tftp_update_fip=mw.b $loadaddr ff 200000 && tftpboot $loadaddr $file_fip && run nand_write_fip && run check_fip_integrity
tftp_update_fw=while true; do tftpboot $loadaddr $file_fw && run tftp_write_fw && run bootcmd; sleep 3; done
tftp_write_fw=if test x$ubien = xtrue && run check_itbimg; then run ubi_write_fw; else run nand_write_fw; fi
ubi_erase_userdata=ubi part ubi && ubi check rootfs_data && ubi remove rootfs_data && ubi create rootfs_data - dynamic && reset
ubi_prep_write=setexpr iosize $filesize + 1efff && setexpr iosize $iosize / 1f000 && setexpr iosize $iosize * 1f000
ubi_read_fw=ubi part ubi && if ubi check kernel; then ubi read $loadaddr kernel; else ubi read $loadaddr fit; fi
ubi_write_fw=ubi detach && mtd erase ubi && ubi part ubi && run ubi_prep_write && ubi create fit $iosize dynamic && setenv iosize && ubi write $loadaddr fit $filesize
ubien=true
